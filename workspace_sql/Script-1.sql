SELECT * FROM emp;

SELECT EMPNO, ENAME, DEPTNO FROM emp;

SELECT DISTINCT DEPTNO
	FROM EMP;

select DISTINCT JOB, DEPTNO
	FROM emp;

SELECT ALL JOB, DEPTNO
	FROM emp;

SELECT ENAME, SAL, SAL*12+COMM, COMM
	FROM emp;

SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM
	FROM emp;

SELECT
	sal,
	ename,
	123,
	'문사eng123'
FROM emp;



WHERE
	deptno IN (10,20);

SELECT * FROM EMP
WHERE
	deptno = 10;

SELECT * FROM emp WHERE deptno = 20;

SELECT * FROM EMP
WHERE
	deptno IN (10,20);


SELECT * FROM EMP WHERE deptno = 10
UNION
SELECT * FROM EMP WHERE deptno = 20;


select empno, ename, sal, deptno
	FROM emp
	WHERE deptno = 10
UNION
SELECT sal, job, deptno, sal
	FROM emp
	WHERE deptno = 20;

SELECT empno, ename, sal, deptno
	FROM EMP
	WHERE deptno = 10
UNION all
SELECT empno, ename, sal, deptno
	FROM emp
	WHERE deptno = 10;

SELECT empno, ename, sal, deptno
	FROM EMP
	WHERE deptno = 10
UNION
SELECT empno, ename, sal, deptno
	FROM EMP
	WHERE deptno = 10;


SELECT EMPNO, ENAME, SAL, DEPTNO
	FROM EMP
	WHERE DEPTNO = 10
UNION
SELECT SAL, JOB, DEPTNO, SAL
	FROM EMP
	WHERE DEPTNO = 20;
	
	
SELECT EMPNO, ENAME, SAL, DEPTNO
	FROM EMP
	ORDER BY EMPNO, SAL desc;

-- 130p
-- 1번
SELECT * FROM EMP
WHERE ename LIKE '%S'
ORDER BY empno;

-- 2번
SELECT empno, ename, job, sal, deptno FROM EMP
WHERE deptno = 30
	AND job = 'SALESMAN'
ORDER BY empno;

-- 3번
SELECT empno, ename, job, sal, deptno FROM EMP
WHERE
	deptno IN (20,30) AND sal >2000
ORDER BY empno;

SELECT empno, ename, job, sal, deptno FROM EMP
WHERE
	deptno = 20 AND sal > 2000
UNION all
SELECT empno, ename, job, sal, deptno FROM EMP
WHERE
	deptno = 30 AND sal > 2000;

-- 4번
SELECT * FROM emp
WHERE not (sal >= 2000 and sal <= 3000)
ORDER BY empno;

SELECT * FROM emp
WHERE sal NOT BETWEEN 2000 AND 3000
ORDER BY empno;

-- 5번
SELECT ename, empno, sal, deptno FROM emp
WHERE
	ename LIKE '%E%'
	AND deptno = 30
	AND sal NOT BETWEEN 1000 AND 2000
ORDER BY ename;

-- 6번
SELECT * FROM EMP
WHERE
	comm IS NULL
	AND mgr IS NOT NULL
	AND job IN ('MANAGER', 'CLERK')
	AND ename NOT LIKE '_L%';

SELECT * FROM EMP
WHERE
	comm IS NULL
	AND mgr IS NOT NULL
	AND (job = 'MANAGER' OR job = 'CLERK')
	-- or로 처리할 시 괄호 사용 필수
	AND ename NOT LIKE '_L%';


-- 97p
-- 2번
SELECT distinct job FROM emp;

-- 3번
SELECT empno employee_no, ename employee_name, mgr manager, sal salary, comm commision, deptno department_no
FROM emp
ORDER BY deptno DESC, ename;


/* 함수 */
-- UPPER, LOWER, INITCAP
SELECT ename, upper(ename), lower(ename), initcap(ename)
FROM emp;

SELECT * FROM EMP
WHERE upper(ename)=upper('scott');

SELECT 1 FROM dual;

SELECT upper('aBc') FROM dual;
SELECT initcap('i am sleepy') FROM dual;
SELECT upper('abc'), upper(123), lower(upper('abc')) FROM dual;

SELECT * FROM emp
WHERE ename LIKE '%AM%';

SELECT * FROM emp
WHERE lower(ename) LIKE lower('%aM%');

-- LENGTH
SELECT ename, length(ename) Name_LENGTH
FROM emp
WHERE LENGTH(ename) >= 5;

SELECT LENGTH('한글'), LENGTHB('한글')
FROM DUAL;

SELECT LENGTH('A'), LENGTH('가'), LENGTHB('A'), LENGTHB('가') FROM DUAL;


-- SUBSTR
SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, -5, 30)
	FROM EMP;

SELECT ENAME, SUBSTR(ENAME, 2, -3) FROM EMP; -- 추출 길이가 0이나 음수이면 NULL 발생
SELECT ENAME, SUBSTR(ENAME, 2, 30) FROM EMP; -- 추출 길이가 크면 끝까지 출력, NULL 및 오류 발생 x
SELECT ENAME, SUBSTR(ENAME, 20, 3) FROM EMP; -- 실제 길이보다 시작 위치가 크면 NULL 발생

SELECT JOB,
	SUBSTR(JOB, -LENGTH(JOB)),
	SUBSTR(JOB, -LENGTH(JOB), 2),
	SUBSTR(JOB, -3)
FROM EMP;

SELECT ENAME, SUBSTR(ENAME, -3, 2) FROM EMP; -- 음수는 뒤에서부터 오른쪽 방향으로 추출

-- IF) -를 지원하지 않는 경우, 뒤에서부터 카운트를 하고 싶으면 LENGTH 활용
SELECT ENAME, SUBSTR(ENAME, LENGTH(ENAME)-2, 2) FROM EMP;
	-- 뒤에서부터 3번째 글자부터 추출, LENGTH(ENAME)-2

SELECT ENAME, SUBSTR(ENAME, LENGTH(ENAME)-20, 2) FROM EMP;
	-- 시작 위치가 전체 길이보다 큼 > NULL 발생

-- INSTR(문자열, 확인할 글자, 시작 위치) > 몇번째에 위치
SELECT INSTR('HELLO, ORACLE', 'L', 5) FROM DUAL;
SELECT INSTR('HELLO, ORACLE', 'Z', 5) FROM DUAL; -- 존재하지 않는 글자는 0 나옴


-- REPLACE(문자열, 대상, 바꿀 글씨)
SELECT 'A-B-C' BEFORE,
	REPLACE('A-B-C', '-', ' ') ONE,
	REPLACE('A-B-C', '-') TWO -- 바꿀 글씨를 비워두면 그냥 생략함
FROM DUAL;

SELECT ENAME, REPLACE(ENAME, 'A', 'abc') replace_name
FROM emp
WHERE ENAME LIKE '%A%';


-- LPAD/RPAD(대상, 전체 자릿수, 채울 글씨) / 채울 글씨를 비우면 공백으로 처리
SELECT LPAD(RPAD('ORACLE', 10, '*'), 15, '#') FROM DUAL;

SELECT ENAME, 
	LPAD(ENAME, 10, '#') LP,
	LPAD(ENAME, 5, '#') FIVE -- 대상의 글자수가 전체 자릿수보다 크면, 전체 자릿수만큼 잘림
FROM EMP;
/* LPAD, RPAD는
 * 모자르면 채우고, 넘치면 자름
 * 즉, 두번째 값의 길이로 만들어줌 */

-- 문제1
	-- ENAME에서 앞글자 두글자만 출력
	-- SUBSTR, REPLACE, LPAD 모두 활용해보기
-- SUBSTR
SELECT ENAME, SUBSTR(ENAME, 1, 2) SUB,
-- REPLACE
	REPLACE(ENAME, SUBSTR(ENAME, 3), '') REP,
-- LPAD/RPAD -> 동일한 결과
	LPAD(ENAME, 2) LP,
	RPAD(ENAME, 2) RP
FROM EMP;

-- 문제2
	-- ENAME의 앞 두글자만 원본을 출력하고 나머지는 4개의 *로 표시
SELECT ENAME, REPLACE(ENAME, SUBSTR(ENAME,3), '****') REP,
	-- ENAME에서 3번째 글자부터 ****로 대체
	RPAD(SUBSTR(ENAME,1,2), 6, '*') RP,
	-- ENAME에서 앞 두글자 추출, 4개의 *을 첨부하여 총 6글자
	CONCAT(SUBSTR(ENAME,1,2), '****') CON
	-- ENAME에서 앞 두글자 추출, ****와 병합
FROM EMP;

-- 문제3
	-- ENAME의 앞 두글자만 원본을 출력하고 나머지는 *로 출력, 단 전체 길이는 원래 이름의 길이만큼
SELECT ENAME, RPAD(SUBSTR(ENAME,1,2), LENGTH(ENAME), '*') MASKING FROM EMP;
	-- ENAME에서 앞 두글자 추출, 나머지 길이만큼 *로 대체

-- 문제4
	-- ENAME의 앞 두글자만 *로 출력
SELECT LPAD(SUBSTR(ENAME, 3), LENGTH(ENAME), '*') LP FROM EMP;
	-- ENAME에서 3번째 자리부터 추출, 원래 길이만큼 *로 대체
SELECT '**'||SUBSTR(ENAME,3) FROM EMP;


-- CONCAT : 많이 사용하진 않음 -> 대신 || 활용
SELECT 'AB', 'CD', 'AB'||'CD' FROM DUAL;

SELECT EMPNO||' : '||ENAME FROM EMP;
SELECT ENAME||' 님' FROM EMP;

SELECT JOB, ENAME||' 매니저' NAME FROM EMP
WHERE JOB='MANAGER'

SELECT 'I '||'LOVE '||'YOU '||'SO '||'MUCH' FROM DUAL;


-- TRIM
SELECT
	TRIM(BOTH '<' FROM '<_ORACLE_>'),
	LTRIM('<_ORACLE_>', '_<'),
	RTRIM('<_ORACLE_>', '_>')
FROM DUAL;

SELECT
	'['||'  _ _ORACLE_ _  '||']',
	'['||TRIM('  _ _ORACLE_ _  ')||']',
	'['||LTRIM('  _ _ORACLE_ _  ')||']',
	'['||RTRIM('  _ _ORACLE_ _  ')||']'
FROM DUAL;


-- 숫자 함수

SELECT ROUND(14.46), ROUND(14.46, -1), ROUND(14.46, 0), ROUND(14.461, 1) FROM DUAL;
-- 14, 10, 14, 14.5

SELECT TRUNC(14.46), TRUNC(14.46, 1), TRUNC(14.46, -1), TRUNC(-14.46) FROM DUAL;
-- 14, 14.4, 10, -14

SELECT CEIL(3.14), FLOOR(3.56), TRUNC(3.14) FROM DUAL;
-- 4, 3, 3

SELECT CEIL(-3.14), FLOOR(-3.14), TRUNC(-3.14) FROM DUAL;
-- -3, -4, -3

SELECT MOD(15,6),
	MOD(10,2),
	MOD(1,2)
FROM DUAL;

SELECT 15/6 FROM DUAL;

--몫
SELECT TRUNC(15/6) FROM DUAL;

SELECT MOD(15/6), MOD(15/0) FROM DUAL;
SELECT MOD(15/0) FROM DUAL;

SELECT MOD(6,3), MOD(7,3), MOD(8,3), MOD(9,3) FROM DUAL;

-- 날짜 함수
SELECT SYSDATE FROM DUAL; -- 선생님 오라클을 사용하는데, 선생님 오라클이 영국 시간으로 기준되어 있어서 시간은 9시간 느리게 나옴
SELECT SYSDATE+20 FROM DUAL;

SELECT TO_DATE(20251216)+0.5,
	TO_NUMBER(20251216)+20
FROM DUAL;

SELECT NEXT_DAY(TO_DATE(20251216), '토요일')
FROM DUAL;

-- 자료형 변환 함수
SELECT TO_CHAR(SYSDATE+9/24, 'YYYY"년" MM"월" DD"일" HH24"시" MI"분" SS"초"') FROM DUAL;

SELECT TO_CHAR(SYSDATE+9/24, 'YYYY년 MM월 DD일 HH24시 MI분 SS초') FROM DUAL;
-- 한글 리터럴 처리가 안 되어 있어서 오류 발생

SELECT * FROM EMP;

SELECT * FROM EMP
WHERE HIREDATE > TO_DATE('1981/06/01', 'YYYY/MM/DD')
ORDER BY SAL DESC;


-- NVL
SELECT EMPNO, ENAME, SAL, COMM, SAL+COMM, 
	NVL(COMM, 0),
	SAL+NVL(COMM, 0)
FROM EMP;

SELECT SAL, COMM, NVL(COMM, 0), SAL+NVL(COMM,0), SAL+COMM
FROM EMP;

-- 조건함수
-- DECODE
SELECT JOB, SAL,
	DECODE(JOB,
	'MANAGER', SAL*1.1,
	'SALESMAN', SAL*1.05,
	'ANALYST', SAL,
	SAL*1.03) AS UASAL
FROM EMP;

-- CASE
SELECT JOB, SAL,
	CASE JOB
		WHEN 'MANAGER' THEN SAL*1.1
		WHEN 'SALESMAN' THEN SAL*1.05
		WHEN 'ANALYST' THEN SAL
		ELSE SAL*1.03
	END AS UPSAL
FROM EMP;

SELECT EMPNO, ENAME, COMM,
	CASE
		WHEN COMM IS NULL THEN '해당 사항 없음'
		WHEN COMM = 0 THEN '수당 없음'
		WHEN COMM > 0 THEN '수당 : '||COMM
	END AS COMM_TEXT
FROM EMP;

SELECT ENAME,
	CASE
		WHEN LENGTH(ENAME)>=6 THEN SUBSTR(ENAME, 1, 5)
		WHEN LENGTH(ENAME)<5 THEN RPAD(ENAME, 5, '*')
		ELSE ENAME
	END AS NAME
FROM EMP;
	

-- 179
-- Q1
SELECT EMPNO,
	RPAD(SUBSTR(EMPNO,1,2), LENGTH(EMPNO), '*') MASKING_EMPNO,
	ENAME,
	RPAD(SUBSTR(ENAME,1,1), 5, '*') MASKING_ENAME
FROM EMP
WHERE LENGTH(ENAME)>=5 AND LENGTH(ENAME)<6;

-- Q2
SELECT EMPNO, ENAME, SAL,
	TRUNC(SAL/21.5,2) DAY_PAY,
	ROUND(SAL/21.5/8,1) TIME_PAY
FROM EMP;

-- Q3
SELECT EMPNO, ENAME, TO_CHAR(HIREDATE, 'YY/MM/DD') HIREDATE,
	TO_CHAR(ADD_MONTHS(HIREDATE, 3), 'YYYY-MM-DD') R_JOB,
	NVL(TO_CHAR(COMM), 'N/A') COMM
FROM EMP;

-- Q4
SELECT EMPNO, ENAME, MGR,
	CASE
		WHEN TO_CHAR(MGR) IS NULL THEN '0000'
		WHEN SUBSTR(MGR,1,2)='75' THEN '5555'
		WHEN SUBSTR(MGR,1,2)='76' THEN '6666'
		WHEN SUBSTR(MGR,1,2)='77' THEN '7777'
		WHEN SUBSTR(MGR,1,2)='78' THEN '8888'
		ELSE TO_CHAR(MGR)
	END AS CHG_MGR
FROM EMP;

-- Q2
SELECT EMPNO, ENAME, SAL,
	TRUNC(SAL/21.5, 2),
	ROUND(SAL/21.5/8, 1)
FROM EMP;

-- Q3
SELECT EMPNO, ENAME,
	TO_CHAR(HIREDATE, 'YY/MM/DD') HIREDATE,
	TO_CHAR(ADD_MONTHS(HIREDATE, 3), 'YYYY-MM-DD') R_JOB,
	NVL(TO_CHAR(COMM), 'N/A')
FROM EMP;

-- Q4
-- CASE 활용
SELECT EMPNO, ENAME, MGR,
	CASE
		WHEN TO_CHAR(MGR) IS NULL THEN '0000'
		WHEN SUBSTR(MGR,1,2)='75' THEN '5555'
		WHEN SUBSTR(MGR,1,2)='76' THEN '6666'
		WHEN SUBSTR(MGR,1,2)='77' THEN '7777'
		WHEN SUBSTR(MGR,1,2)='78' THEN '8888'
		ELSE TO_CHAR(MGR)
	END AS CHG_MGR
FROM EMP;

SELECT EMPNO, ENAME, MGR,
	CASE
		WHEN MGR IS NULL THEN '0000'
		WHEN SUBSTR(MGR,1,2)=75 THEN '5555'
		WHEN SUBSTR(MGR,1,2)=76 THEN '6666'
		WHEN SUBSTR(MGR,1,2)=77 THEN '7777'
		WHEN SUBSTR(MGR,1,2)=78 THEN '8888'
		ELSE TO_CHAR(MGR)
	END AS CHG_MGR
FROM EMP;
-- > 동일 컬럼 내 데이터셋만 같으면 무관. MGR 컬럼은 숫자, CHG_MGR 컬럼은 문자로 변환해도 기능함

-- CASE 활용, ELSE에 NULL 조건
SELECT EMPNO, ENAME, MGR,
	CASE
		WHEN SUBSTR(MGR,1,2)='75' THEN '5555'
		WHEN SUBSTR(MGR,1,2)='76' THEN '6666'
		WHEN SUBSTR(MGR,1,2)='77' THEN '7777'
		WHEN SUBSTR(MGR,1,2)='78' THEN '8888'
	 ELSE
	 	CASE
	 		WHEN MGR IS NULL THEN '0000'
	 		ELSE TO_CHAR(MGR)
	 	END
	END AS CHG_MGR
FROM EMP;

-- CASE 기준 데이터 적용, ELSE에 NULL
SELECT EMPNO, ENAME, MGR,
	CASE SUBSTR(MGR,1,2)
	 WHEN '75' THEN '5555'
	 WHEN '76' THEN '6666'
	 WHEN '77' THEN '7777'
	 WHEN '78' THEN '8888'
	 ELSE
	 	CASE
	 		WHEN MGR IS NULL THEN '0000'
	 		ELSE TO_CHAR(MGR)
	 	END
	END AS CHG_MGR
FROM EMP;



-- CASE 기준데이터 활용, UNION ALL 활용하여 NULL 따로 처리
SELECT EMPNO, ENAME, MGR,
	CASE SUBSTR(MGR,1,2)
	 WHEN '75' THEN '5555'
	 WHEN '76' THEN '6666'
	 WHEN '77' THEN '7777'
	 WHEN '78' THEN '8888'
	 ELSE TO_CHAR(MGR)
	 END AS CHG_MGR
FROM EMP
WHERE MGR IS NOT NULL
UNION ALL
SELECT EMPNO, ENAME, MGR,
	CASE
		WHEN MGR IS NULL THEN '0000'
	END AS CHG_MGR
FROM EMP
WHERE MGR IS NULL;

-- DECODE 활용, UNION ALL 활용하여 NULL 따로 처리
SELECT EMPNO, ENAME, MGR,
	DECODE(SUBSTR(MGR,1,2),
	'75', '5555',
	'76', '6666',
	'77', '7777',
	'78', '8888',
	TO_CHAR(MGR)) AS CHG_MGR
FROM EMP
WHERE MGR IS NOT NULL
UNION ALL
SELECT EMPNO, ENAME, MGR,
	DECODE(MGR, NULL, '0000') AS CHG_MGR
FROM EMP
WHERE MGR IS NULL;
	
SELECT EMPNO, ENAME, MGR,
	CASE 
		WHEN RPAD(MGR,2)='75' THEN '5555'
		WHEN RPAD(MGR,2)='76' THEN '6666'
		WHEN RPAD(MGR,2)='77' THEN '7777'
		WHEN RPAD(MGR,2)='78' THEN '8888'
		ELSE
		CASE
			WHEN MGR IS NULL THEN '0000'
			ELSE TO_CHAR(MGR)
			END
	END
FROM EMP;

-- GPT 쪼아내서 받은 답변. 숫자 타입으로 저장하면서 0000으로 변환하는 건 불가능. 변환 시에 문자 타입으로 변경해야 함.
SELECT EMPNO, ENAME, MGR,
       TO_CHAR(
           CASE 
               WHEN RPAD(MGR,2) = '75' THEN 5555
               WHEN RPAD(MGR,2) = '76' THEN 6666
               WHEN RPAD(MGR,2) = '77' THEN 7777
               WHEN RPAD(MGR,2) = '78' THEN 8888
               WHEN MGR IS NULL THEN 0
               ELSE MGR
           END,
           'FM0000'
       ) AS CHG_MGR
FROM EMP;

SELECT AVG(SAL) AS AVG
FROM EMP
WHERE DEPTNO = 10
	UNION ALL
SELECT AVG(SAL) AS AVG
FROM EMP
WHERE DEPTNO = 20
	UNION ALL
SELECT AVG(SAL) AS AVG
FROM EMP
WHERE DEPTNO = 30;

SELECT AVG(SAL), DEPTNO
	FROM EMP
GROUP BY DEPTNO;

-- 200P
-- Q1
SELECT DEPTNO, ROUND(AVG(SAL),0) AVG, MAX(SAL) MAX, MIN(SAL) MIN, COUNT(ENAME) CNT
FROM EMP
GROUP BY DEPTNO
ORDER BY MIN;

--Q2
SELECT JOB, COUNT(ENAME) CNT
FROM EMP
GROUP BY JOB
HAVING COUNT(ENAME)>=3
ORDER BY CNT DESC;

